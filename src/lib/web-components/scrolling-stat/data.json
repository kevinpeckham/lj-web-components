{"name":"scrolling-stat","max":"/** @copyright 2024 Lightning Jar - \"Scrolling Stat\" web component - License MIT */\n/** @author Kevin Peckham */\n/** @license MIT */\n/** @version 0.0.1 */\n/** {@link https://www.lj-cdn.dev/web-components/scrolling-stat} */\n\n/**\n * Scrolling Stat Web Component\n * @class\n * @extends HTMLElement\n * @classdesc Defines web component that displays a number that counts up when it is scrolled into view.\n * @attribute {string} [data-duration=800] The duration of the animation in milliseconds.\n * @attribute {string} [data-number-start=0] The starting number.\n * @attribute {string} [data-number-end=99] The ending number.\n * @attribute {string} [data-unit=\"\"] The unit of measurement.\n * @attribute {string} [data-text=\"\"] The text to display below the number.\n *\n */\nclass ScrollingStat extends HTMLElement {\n  isOnScreen = false;\n  start = 0;\n  numberSpan = document.createElement(\"span\");\n\n  /**\n   * Attributes to observe for adding, removing, or changing.\n   * @static\n   * @returns {string[]} An array of attribute names to observe.\n   */\n  static get observedAttributes() {\n    return [\n      \"data-duration\",\n      \"data-number-start\",\n      \"data-number-end\",\n      \"data-unit\",\n      \"data-text\",\n    ];\n  }\n\n  // constructor\n  constructor() {\n    super();\n\n    // binding the parent context to the methods\n    this.connectedCallback = this.connectedCallback.bind(this);\n    this.tween = this.tween.bind(this);\n    this.observerCallback = this.observerCallback.bind(this);\n  }\n  /**\n   * Method invoked when the custom element is first connected to the document's DOM. Defines DOM elements, adds css styling, and starts the observer.\n   * @method\n   * @returns {void}\n   * @summary Creates the shadow DOM, add styles, and starts the observer.\n   */\n  connectedCallback() {\n    // create a shadow root\n    const shadowRoot = this.attachShadow({ mode: \"open\" }),\n      elem = document.createElement(\"span\"),\n      unitElem = document.createElement(\"span\"),\n      textElem = document.createElement(\"span\"),\n      styleElem = document.createElement(\"style\"),\n      attrs = [\"data-text\", \"data-unit\"].map(\n        (attr) => this.getAttribute(attr) || \"\",\n      );\n\n    // add text content\n    this.numberSpan.textContent = \"0\";\n    [textElem.textContent, unitElem.textContent] = attrs;\n\n    // add the style rules\n    styleElem.textContent = `\n    host:, * { margin:0;box-sizing:border-box; }\n    #w {\n      align-items:baseline;\n      background:rgb(100%100%100%/5%);\n      border-radius:.3em;\n      display:grid;\n      font-weight:800;\n      gap:.3em;\n      grid:auto-flow/auto 1fr;\n      line-height:1;\n      outline:1px solid;\n      padding:1.5em;\n      max-width:12em;\n    }\n    #w span:nth-child(1) {\n      font-size:2.75em;\n    }\n    #w span:nth-child(2) {\n      font-size:1.9em;\n    }\n    #w span:nth-child(3) {\n      font-size:.9em;\n      font-style:italic;\n      font-weight:400;\n      grid-column:1/span 2;\n      line-height:1.3;\n      opacity:.9;\n    }`;\n\n    // append to shadow DOM\n    shadowRoot.replaceChildren(styleElem, elem);\n    elem.replaceChildren(this.numberSpan, unitElem, textElem);\n    elem.id = \"w\";\n\n    // create the observer\n    const observer = new IntersectionObserver(this.observerCallback, {\n      rootMargin: \"0%\",\n      threshold: 0.5,\n    });\n\n    // start the observer\n    observer.observe(elem);\n  }\n  /**\n   * @param {IntersectionObserverEntry[]} entries\n   * @returns {void}\n   * @description callback method which fires when the element is scrolled into view\n   */\n  observerCallback(entries) {\n    // test if the element is on screen\n    const isVisible = entries[0].isIntersecting;\n\n    // if on screen and not already on screen, start the animation\n    if (isVisible != this.isOnScreen) {\n      this.start = 0;\n      this.tween();\n      this.isOnScreen = isVisible;\n    }\n  }\n  /**\n   * Tween Method\n   * @method\n   * @returns {void}\n   * @example\n   * tween(0, 99)\n   */\n  tween() {\n    // record the start time\n    if (!this.start) this.start = Date.now();\n\n    // get the duration\n    const duration = Math.abs(\n        parseInt(this.getAttribute(\"data-duration\") || \"800\"),\n      ),\n      // get the end value\n      endValue = parseFloat(this.getAttribute(\"data-number-end\") || \"99\"),\n      // get the start value\n      // @ts-expect-error -- parseFloat will coerce the string to a number\n      // prettier-ignore\n      startValue = parseFloat(this.getAttribute(\"data-number-start\") || (Math.abs(endValue) > 49 ? 0 : endValue > 0 ? 99 : -99)),\n      // get progress\n      progress = Math.min((Date.now() - this.start) / duration, 1),\n      // get the current value\n      currentValue = startValue + (endValue - startValue) * progress,\n      // decimal places -- limit to 2\n      decimalPlaces = Math.min((`${endValue}`.split(\".\")[1] || \"\").length, 2);\n\n    // advance the displayed number\n    this.numberSpan.textContent = currentValue.toFixed(decimalPlaces);\n\n    // if the current number is not yet the target number, request another frame\n    Date.now() - this.start < duration &&\n    endValue - Number(this.numberSpan.textContent)\n      ? window.requestAnimationFrame(() => this.tween())\n      : // set the final number\n        (this.numberSpan.textContent = endValue.toFixed(decimalPlaces));\n  }\n}\ncustomElements.define(\"scrolling-stat\", ScrollingStat);\nexport default ScrollingStat;\n","min":"class ScrollingStat extends HTMLElement{isOnScreen=!1;start=0;numberSpan=document.createElement(\"span\");static get observedAttributes(){return[\"data-duration\",\"data-number-start\",\"data-number-end\",\"data-unit\",\"data-text\"]}constructor(){super(),this.connectedCallback=this.connectedCallback.bind(this),this.tween=this.tween.bind(this),this.observerCallback=this.observerCallback.bind(this)}connectedCallback(){const t=this.attachShadow({mode:\"open\"}),e=document.createElement(\"span\"),n=document.createElement(\"span\"),a=document.createElement(\"span\"),i=document.createElement(\"style\"),s=[\"data-text\",\"data-unit\"].map((t=>this.getAttribute(t)||\"\"));this.numberSpan.textContent=\"0\",[a.textContent,n.textContent]=s,i.textContent=\" host:, * {margin:0;box-sizing:border-box}#w {align-items:baseline;background:rgb(100%100%100%/5%);border-radius:.3em;display:grid;font-weight:800;gap:.3em;grid:auto-flow/auto 1fr;line-height:1;outline:1px solid;padding:1.5em;max-width:12em}#w span:nth-child(1){font-size:2.75em}#w span:nth-child(2){font-size:1.9em}#w span:nth-child(3){font-size:.9em;font-style:italic;font-weight:400;grid-column:1/span 2;line-height:1.3;opacity:.9}\",t.replaceChildren(i,e),e.replaceChildren(this.numberSpan,n,a),e.id=\"w\";new IntersectionObserver(this.observerCallback,{rootMargin:\"0%\",threshold:.5}).observe(e)}observerCallback(t){const e=t[0].isIntersecting;e!=this.isOnScreen&&(this.start=0,this.tween(),this.isOnScreen=e)}tween(){this.start||(this.start=Date.now());const t=Math.abs(parseInt(this.getAttribute(\"data-duration\")||\"800\")),e=parseFloat(this.getAttribute(\"data-number-end\")||\"99\"),n=parseFloat(this.getAttribute(\"data-number-start\")||(Math.abs(e)>49?0:e>0?99:-99)),a=n+(e-n)*Math.min((Date.now()-this.start)/t,1),i=Math.min((`${e}`.split(\".\")[1]||\"\").length,2);this.numberSpan.textContent=a.toFixed(i),Date.now()-this.start<t&&e-Number(this.numberSpan.textContent)?window.requestAnimationFrame((()=>this.tween())):this.numberSpan.textContent=e.toFixed(i)}}customElements.define(\"scrolling-stat\",ScrollingStat);export default ScrollingStat;"}